<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WaferMap 模拟器 Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Add SheetJS for Excel Export -->
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <!-- Add Dexie for IndexedDB -->
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; overflow: hidden; }
        
        .custom-scroll::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 4px; }

        .popup-window { animation: fadeIn 0.15s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        
        .modal-overlay { background-color: rgba(0, 0, 0, 0.5); backdrop-filter: blur(2px); }
        .folder-card:hover { transform: translateY(-2px); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
    </style>
</head>
<body class="bg-gray-100 text-slate-800">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useLayoutEffect, useMemo } = React;

        // --- 0. 数据库配置 (IndexedDB via Dexie) ---
        const db = new Dexie('WaferMapDB');
        db.version(1).stores({
            projects: '++id, name, folderPath, updatedAt' // Index for searching/sorting
        });

        // --- 1. 基础配置 ---
        const PRESET_COLORS = [
            { name: 'Blue', fill: '#3b82f6', stroke: '#1d4ed8' },
            { name: 'Purple', fill: '#a855f7', stroke: '#7e22ce' },
            { name: 'Pink', fill: '#ec4899', stroke: '#be185d' },
            { name: 'Yellow', fill: '#eab308', stroke: '#a16207' },
            { name: 'Cyan', fill: '#06b6d4', stroke: '#0e7490' },
            { name: 'Green', fill: '#22c55e', stroke: '#15803d' },
            { name: 'Red', fill: '#ef4444', stroke: '#b91c1c' },
            { name: 'Orange', fill: '#f97316', stroke: '#c2410c' },
            { name: 'Slate', fill: '#64748b', stroke: '#334155' },
        ];
        const darkenColor = (hex, percent) => {
            let num = parseInt(hex.replace("#",""), 16), amt = Math.round(2.55 * percent), R = (num >> 16) - amt, B = ((num >> 8) & 0x00FF) - amt, G = (num & 0x0000FF) - amt;
            return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (B<255?B<1?0:B:255)*0x100 + (G<255?G<1?0:G:255)).toString(16).slice(1);
        };
        const resolveColor = (colorIdx, customColor) => customColor ? { fill: customColor, stroke: darkenColor(customColor, 20) } : PRESET_COLORS[colorIdx % PRESET_COLORS.length];
        const DEFECT_COLOR = { fill: '#334155', stroke: '#1e293b' }; 

        const T = {
            title: "WaferMap Simulator", 
            goodDies: "Good Die", edgeDies: "Edge Die", defectDies: "Defect Die",
            exportGDS: "Export GDS", exportExcel: "Export Excel",
            waferParams: "Wafer Setup", size: "Diameter", exclusion: "Edge Exclusion (mm)", 
            waferType: "Notch/Flat", notch: "Notch", flat: "Flat", flatLength: "Flat Length (mm)", orientation: "Orientation (deg)",
            singleMode: "Single Die", shotMode: "Multi Die",
            chipParams: "Shot Definition", mpwSettings: "Die Groups",
            addDie: "Add Group", resultStats: "Summary",
            defectDensity: "Defect Density (per mm²)",
            highDensityMsg: "⚠️ High Density", highDensityDesc: "Count > 100k. Drawing disabled for performance.",
            tooHeavyMsg: "⚠️ Calculation Limit", tooHeavyDesc: "Grid points > 2M. Calculation stopped to prevent crash.",
            resetView: "Reset View"
        };

        const Icons = {
            Disc: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3"/></svg>,
            Settings: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0 .73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>,
            Layout: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M9 21V9"/></svg>,
            Layers: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83Z"/><path d="m22 17.65-9.17 4.16a2 2 0 0 1-1.66 0L2 17.65"/><path d="m22 12.65-9.17 4.16a2 2 0 0 1-1.66 0L2 12.65"/></svg>,
            Grid: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></svg>,
            Download: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>,
            Sheet: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="3" x2="21" y1="9" y2="9"/><line x1="3" x2="21" y1="15" y2="15"/><line x1="9" x2="9" y1="9" y2="21"/><line x1="15" x2="15" y1="9" y2="21"/></svg>,
            Plus: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>,
            Trash2: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>,
            AlertCircle: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></svg>,
            RefreshCw: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6.7L3 16"/></svg>,
            ZoomIn: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="11" x2="11" y1="8" y2="14"/><line x1="8" x2="14" y1="11" y2="11"/></svg>,
            ZoomOut: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="8" x2="14" y1="11" y2="11"/></svg>,
            X: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
            Shuffle: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line></svg>,
            Save: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>,
            Folder: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>,
            File: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>,
            Home: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>,
            ArrowRight: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>,
            MoreVertical: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>
        };

        // --- GDS Engine ---
        class GDSWriter {
            constructor() { this.buffer = []; this.bufferLength = 0; }
            addRecord(cmd, dataType, data = []) {
                let length = 4;
                if (dataType === 1 || dataType === 2) length += data.length * 2;
                else if (dataType === 3) length += data.length * 4;
                else if (dataType === 6) { length += data.length; if (length % 2 !== 0) length++; }
                const buffer = new ArrayBuffer(length);
                const view = new DataView(buffer);
                view.setUint16(0, length); view.setUint8(2, cmd); view.setUint8(3, dataType);
                let offset = 4;
                if (dataType === 2) { data.forEach(val => { view.setInt16(offset, val); offset += 2; }); }
                else if (dataType === 3) { data.forEach(val => { view.setInt32(offset, val); offset += 4; }); }
                else if (dataType === 6) { for (let i = 0; i < data.length; i++) { view.setUint8(offset++, data.charCodeAt(i)); } if (length > 4 + data.length) view.setUint8(offset, 0); }
                this.buffer.push(buffer); this.bufferLength += length;
            }
            writeHeader() { this.addRecord(0x00, 0x02, [600]); }
            writeBgnLib() { const now = new Date(); const t = [now.getFullYear(), now.getMonth()+1, now.getDate(), now.getHours(), now.getMinutes(), now.getSeconds()]; this.addRecord(0x01, 0x02, [...t, ...t]); }
            writeLibName(name) { this.addRecord(0x02, 0x06, name); }
            writeUnits() { const buffer = new ArrayBuffer(20); const view = new DataView(buffer); view.setUint16(0, 20); view.setUint8(2, 0x03); view.setUint8(3, 0x05); const u1 = [0x3E, 0x41, 0x89, 0x37, 0x4B, 0xC6, 0xA7, 0xEF]; const u2 = [0x39, 0x44, 0xB8, 0x2F, 0xA0, 0x9B, 0x5A, 0x52]; for(let i=0; i<8; i++) view.setUint8(4+i, u1[i]); for(let i=0; i<8; i++) view.setUint8(12+i, u2[i]); this.buffer.push(buffer); }
            writeBgnStr(name) { const now = new Date(); const t = [now.getFullYear(), now.getMonth()+1, now.getDate(), now.getHours(), now.getMinutes(), now.getSeconds()]; this.addRecord(0x05, 0x02, [...t, ...t]); this.addRecord(0x06, 0x06, name); }
            writePath(layer, dataType, width, xy) { this.addRecord(0x09, 0x00); this.addRecord(0x0D, 0x02, [layer]); this.addRecord(0x0E, 0x02, [dataType]); this.addRecord(0x21, 0x02, [0]); this.addRecord(0x0F, 0x03, [width]); this.addRecord(0x10, 0x03, xy); this.addRecord(0x11, 0x00); }
            writeBoundary(layer, dataType, xy) { this.addRecord(0x08, 0x00); this.addRecord(0x0D, 0x02, [layer]); this.addRecord(0x0E, 0x02, [dataType]); this.addRecord(0x10, 0x03, xy); this.addRecord(0x11, 0x00); }
            writeEndStr() { this.addRecord(0x07, 0x00); }
            writeEndLib() { this.addRecord(0x04, 0x00); }
            getBlob() { return new Blob(this.buffer, { type: 'application/octet-stream' }); }
        }

        // --- Common UI ---
        const NumberInput = ({ label, value, onChange, step = "0.01", icon: Icon, suffix, className, children }) => (
            <div className={className}>
                <label className="block text-xs font-medium text-gray-500 mb-0.5 truncate" title={label}>{label}</label>
                <div className="flex gap-1">
                    <div className="relative rounded-md shadow-sm flex-1">
                        {Icon && (<div className="absolute inset-y-0 left-0 pl-2 flex items-center pointer-events-none text-gray-400"><Icon /></div>)}
                        <input type="number" value={value} onChange={(e) => onChange(e.target.value)} step="any" className={`focus:ring-indigo-500 focus:border-indigo-500 block w-full text-sm border-gray-300 rounded-md ${Icon ? 'pl-8' : 'pl-2'} pr-2 py-1 border transition-shadow`} placeholder="0" />
                        {suffix && (<div className="absolute inset-y-0 right-0 pr-2 flex items-center pointer-events-none"><span className="text-gray-400 text-sm">{suffix}</span></div>)}
                    </div>
                    {children}
                </div>
            </div>
        );

        const AlignmentSelector = ({ mode, onChange }) => (
            <div className="grid grid-cols-2 gap-2 mt-0.5">
                <button onClick={() => onChange('center')} className={`flex flex-col items-center justify-center p-1.5 rounded border transition-all ${mode === 'center' ? 'border-gray-500 bg-gray-50 text-gray-700 ring-1 ring-gray-500' : 'border-gray-200 hover:border-gray-300 text-gray-600 bg-white'}`}><div className="w-3 h-3 bg-gray-500 rounded-sm mb-0.5"></div><span className="text-[10px] font-bold text-gray-500 uppercase">{T.center}</span></button>
                <button onClick={() => onChange('vertex')} className={`flex flex-col items-center justify-center p-1.5 rounded border transition-all ${mode === 'vertex' ? 'border-gray-500 bg-gray-50 text-gray-700 ring-1 ring-gray-500' : 'border-gray-200 hover:border-gray-300 text-gray-600 bg-white'}`}><div className="grid grid-cols-2 gap-0.5 w-3 h-3 mb-0.5"><div className="bg-gray-400 rounded-sm"></div><div className="bg-gray-400 rounded-sm"></div><div className="bg-gray-400 rounded-sm"></div><div className="bg-gray-400 rounded-sm"></div></div><span className="text-[10px] font-bold text-gray-500 uppercase">{T.vertex}</span></button>
            </div>
        );

        const ViewControls = ({ unit, onUnitChange, showLabels, onShowLabelsChange, bgColor, onBgColorChange }) => (
            <div className="flex flex-col justify-end h-full pb-0.5">
                <div className="flex items-center justify-between gap-1 h-[28px]">
                    <div className="flex bg-gray-100 rounded p-0.5 border border-gray-200"><button onClick={() => onUnitChange('mm')} className={`px-2 py-0.5 text-[11px] rounded ${unit==='mm' ? 'bg-white font-bold text-indigo-700 shadow-sm' : 'text-gray-400'}`}>mm</button><button onClick={() => onUnitChange('um')} className={`px-2 py-0.5 text-[11px] rounded ${unit==='um' ? 'bg-white font-bold text-indigo-700 shadow-sm' : 'text-gray-400'}`}>μm</button></div>
                    <div className="w-px h-4 bg-gray-200 mx-1"></div>
                    <label className="flex items-center gap-1 cursor-pointer select-none" title={T.showLabels}><input type="checkbox" checked={showLabels} onChange={e => onShowLabelsChange(e.target.checked)} className="h-3 w-3 text-indigo-600 rounded border-gray-300" /><span className="text-[11px] font-bold text-gray-500 uppercase">Lbl</span></label>
                    <div className="w-px h-4 bg-gray-200 mx-1"></div>
                    <label className="flex items-center gap-1 cursor-pointer select-none" title={T.bgColor}><div className="w-4 h-4 rounded border border-gray-300 overflow-hidden relative"><input type="color" value={bgColor} onChange={e => onBgColorChange(e.target.value)} className="absolute -top-2 -left-2 w-8 h-8 p-0 border-0 cursor-pointer" /></div><span className="text-[11px] font-bold text-gray-500 uppercase">BG</span></label>
                </div>
            </div>
        );

        const Modal = ({ title, children, onClose, maxWidth="max-w-4xl" }) => (
            <div className="fixed inset-0 z-50 flex items-center justify-center modal-overlay" onClick={onClose}>
                <div className={`bg-white rounded-lg shadow-2xl w-[90%] ${maxWidth} max-h-[90vh] flex flex-col`} onClick={e => e.stopPropagation()}>
                    <div className="flex justify-between items-center px-4 py-3 border-b border-gray-100"><h3 className="text-sm font-bold text-gray-800">{title}</h3><button onClick={onClose} className="text-gray-400 hover:text-gray-600"><Icons.X /></button></div>
                    <div className="flex-1 overflow-auto p-4 custom-scroll">{children}</div>
                </div>
            </div>
        );

        // --- NEW: Project Manager Component ---
        const ProjectManager = ({ onClose, onLoad }) => {
            const [projects, setProjects] = useState([]);
            const [currentPath, setCurrentPath] = useState(''); // Empty string = root
            
            useEffect(() => {
                db.projects.toArray().then(setProjects);
            }, []);

            const handleDelete = async (id, e) => {
                e.stopPropagation();
                if (confirm('Are you sure you want to delete this project?')) {
                    await db.projects.delete(id);
                    setProjects(prev => prev.filter(p => p.id !== id));
                }
            };

            const getFoldersAndFiles = () => {
                const folders = new Set();
                const files = [];
                const prefix = currentPath ? currentPath + '/' : '';

                projects.forEach(p => {
                    if (p.folderPath && p.folderPath.startsWith(prefix)) {
                        const remaining = p.folderPath.slice(prefix.length);
                        const parts = remaining.split('/');
                        if (parts.length > 0 && parts[0] !== "") {
                            // If remaining part has slashes, it's a subfolder
                             if (remaining.includes('/')) { // Wait, logic: folderPath is full path. 
                                 // e.g. current='', path='Peng/ProdA'. remaining='Peng/ProdA'. parts[0]='Peng'. 
                                 // It is a folder.
                                 folders.add(parts[0]);
                             } else {
                                 // e.g. current='Peng', path='Peng/ProdA'. remaining='ProdA'. parts[0]='ProdA'. 
                                 // Is 'ProdA' a folder containing the project? 
                                 // The logic is: folderPath IS the folder structure. 
                                 // If path is "A/B", and current is "A", then "B" is a subfolder.
                                 // If path is "A", and current is "A", then the project is IN current folder.
                                 
                                 if (p.folderPath === currentPath) {
                                     files.push(p);
                                 } else {
                                     folders.add(parts[0]);
                                 }
                             }
                        } else if (p.folderPath === currentPath) {
                             files.push(p);
                        }
                    } else if (!currentPath && !p.folderPath) {
                        files.push(p);
                    }
                });
                return { folders: Array.from(folders).sort(), files: files.sort((a,b) => b.updatedAt - a.updatedAt) };
            };

            const { folders, files } = getFoldersAndFiles();
            const breadcrumbs = currentPath ? currentPath.split('/') : [];

            return (
                <Modal title="Project Manager" onClose={onClose} maxWidth="max-w-6xl">
                    {/* Breadcrumbs */}
                    <div className="flex items-center gap-2 mb-6 text-sm">
                        <button onClick={() => setCurrentPath('')} className="flex items-center gap-1 text-gray-500 hover:text-indigo-600 font-bold"><Icons.Home /> Home</button>
                        {breadcrumbs.map((crumb, idx) => (
                            <React.Fragment key={idx}>
                                <span className="text-gray-300">/</span>
                                <button 
                                    onClick={() => setCurrentPath(breadcrumbs.slice(0, idx+1).join('/'))}
                                    className={`font-medium ${idx === breadcrumbs.length-1 ? 'text-gray-800' : 'text-gray-500 hover:text-indigo-600'}`}
                                >
                                    {crumb}
                                </button>
                            </React.Fragment>
                        ))}
                    </div>

                    <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-4">
                        {/* Folders */}
                        {folders.map(folder => (
                            <div key={folder} onClick={() => setCurrentPath(currentPath ? `${currentPath}/${folder}` : folder)} 
                                 className="folder-card bg-indigo-50 border border-indigo-100 rounded-xl p-4 cursor-pointer flex flex-col items-center justify-center gap-2 transition-all h-32">
                                <div className="text-indigo-400"><Icons.Folder /></div>
                                <div className="text-sm font-bold text-indigo-900 truncate w-full text-center">{folder}</div>
                            </div>
                        ))}

                        {/* Files */}
                        {files.map(p => (
                            <div key={p.id} onClick={() => onLoad(p)} className="folder-card bg-white border border-gray-200 rounded-xl overflow-hidden cursor-pointer flex flex-col transition-all group h-64 shadow-sm hover:shadow-md hover:border-indigo-300">
                                <div className="h-32 bg-slate-100 relative border-b border-gray-100">
                                    {p.thumbnail ? <img src={p.thumbnail} className="w-full h-full object-contain" /> : <div className="w-full h-full flex items-center justify-center text-gray-300"><Icons.Disc /></div>}
                                    <button onClick={(e) => handleDelete(p.id, e)} className="absolute top-2 right-2 p-1.5 bg-white rounded-full text-gray-400 hover:text-red-500 shadow-sm opacity-0 group-hover:opacity-100 transition-opacity"><Icons.Trash2 /></button>
                                </div>
                                <div className="p-3 flex-1 flex flex-col text-xs text-gray-600 gap-1 bg-white">
                                    <div className="font-bold text-gray-800 text-sm truncate mb-1" title={p.name}>{p.name}</div>
                                    <div className="flex justify-between"><span>Wafer:</span> <span>{p.meta?.waferSize}mm / {p.meta?.waferType}</span></div>
                                    <div className="flex justify-between"><span>Die:</span> <span>{p.meta?.dieSize}mm</span></div>
                                    <div className="flex justify-between"><span>Yield:</span> <span className="font-bold text-emerald-600">{p.meta?.yield}</span></div>
                                    <div className="flex justify-between"><span>Valid:</span> <span>{p.meta?.goodDie}</span></div>
                                    <div className="mt-auto pt-2 text-gray-400 text-[10px] flex justify-between items-center border-t border-gray-50">
                                        <span>{new Date(p.updatedAt).toLocaleDateString()}</span>
                                    </div>
                                </div>
                            </div>
                        ))}
                        
                        {folders.length === 0 && files.length === 0 && (
                            <div className="col-span-full py-12 text-center text-gray-400">This folder is empty</div>
                        )}
                    </div>
                </Modal>
            );
        };

        const SaveModal = ({ onSave, onClose }) => {
            const [name, setName] = useState('');
            const [owner, setOwner] = useState('User');
            const [product, setProduct] = useState('Product');
            const [variant, setVariant] = useState('Variant');
            
            const handleConfirm = () => {
                if (!name) return alert('Please enter a project name');
                onSave({ name, folderPath: `${owner}/${product}/${variant}`, owner, product, variant });
            };

            return (
                <Modal title="Save Project" onClose={onClose} maxWidth="max-w-md">
                    <div className="space-y-4">
                        <div>
                            <label className="block text-xs font-bold text-gray-500 mb-1">Project Name (File Name)</label>
                            <input type="text" value={name} onChange={e => setName(e.target.value)} className="w-full border border-gray-300 rounded px-3 py-2 text-sm focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="e.g. Wafer_Map_Rev1" autoFocus />
                        </div>
                        <div className="bg-gray-50 p-3 rounded-lg border border-gray-200 space-y-3">
                            <div className="text-xs font-bold text-gray-400 uppercase tracking-wider">Folder Structure</div>
                            <div>
                                <label className="block text-xs font-medium text-gray-500 mb-1">L1: Owner / Department</label>
                                <input type="text" value={owner} onChange={e => setOwner(e.target.value)} className="w-full border border-gray-300 rounded px-2 py-1.5 text-xs" />
                            </div>
                            <div>
                                <label className="block text-xs font-medium text-gray-500 mb-1">L2: Product Name</label>
                                <input type="text" value={product} onChange={e => setProduct(e.target.value)} className="w-full border border-gray-300 rounded px-2 py-1.5 text-xs" />
                            </div>
                            <div>
                                <label className="block text-xs font-medium text-gray-500 mb-1">L3: Variant / Application</label>
                                <input type="text" value={variant} onChange={e => setVariant(e.target.value)} className="w-full border border-gray-300 rounded px-2 py-1.5 text-xs" />
                            </div>
                            <div className="text-[10px] text-gray-400 mt-1 flex gap-1"><Icons.Folder /> Path: {owner}/{product}/{variant}</div>
                        </div>
                        <div className="flex justify-end gap-2 mt-4">
                             <button onClick={onClose} className="px-4 py-2 text-sm text-gray-600 font-medium hover:bg-gray-100 rounded">Cancel</button>
                             <button onClick={handleConfirm} className="px-4 py-2 bg-indigo-600 text-white text-sm font-bold rounded hover:bg-indigo-700 shadow">Save Project</button>
                        </div>
                    </div>
                </Modal>
            );
        };

        const GDSLayerModal = ({ layers, onUpdate, onClose }) => {
            const [localLayers, setLocalLayers] = useState(layers);
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center modal-overlay" onClick={onClose}>
                    <div className="bg-white rounded-lg shadow-2xl w-[300px] p-4" onClick={e => e.stopPropagation()}>
                        <h3 className="text-sm font-bold text-gray-800 mb-4">GDS Layer Config</h3>
                        <div className="space-y-3 mb-4">{Object.entries(localLayers).map(([k, v]) => (<div key={k} className="flex justify-between items-center"><label className="text-xs font-medium text-gray-600 capitalize">{k}</label><input type="number" value={v} onChange={e => setLocalLayers(p => ({...p, [k]: parseInt(e.target.value)||0}))} className="w-16 border rounded px-2 py-1 text-xs text-right" /></div>))}</div>
                        <div className="flex justify-end gap-2"><button onClick={onClose} className="px-3 py-1.5 text-xs text-gray-600 hover:bg-gray-100 rounded">Cancel</button><button onClick={() => { onUpdate(localLayers); onClose(); }} className="px-3 py-1.5 text-xs text-white bg-indigo-600 hover:bg-indigo-700 rounded font-medium">Save</button></div>
                    </div>
                </div>
            );
        };
        const DieListModal = ({ label, dies, unit, onClose }) => {
            const exportList = () => { const uStr = unit==='mm'?'(mm)':'(um)'; const headers = ["Index", "Name", "Type", "Shot Col", "Shot Row", `Center X ${uStr}`, `Center Y ${uStr}`, `Width ${uStr}`, `Height ${uStr}`]; const data = dies.map((d, i) => [ i+1, d.label || 'Single', d.status, d.shotC, d.shotR, d.x, d.y, d.w, d.h ]); const wb = XLSX.utils.book_new(); const ws = XLSX.utils.aoa_to_sheet([headers, ...data]); XLSX.utils.book_append_sheet(wb, ws, `${label}_Dies`); XLSX.writeFile(wb, `Dies_${label}.xlsx`); };
            return (
                <Modal title={`Detailed Die List: ${label}`} onClose={onClose} maxWidth="max-w-5xl">
                    <div className="flex justify-end mb-2"><button onClick={exportList} className="flex items-center gap-2 bg-emerald-600 text-white px-3 py-1.5 rounded text-xs hover:bg-emerald-700"><Icons.Sheet /> Export List</button></div>
                    <div className="overflow-x-auto"><table className="min-w-full divide-y divide-gray-200"><thead className="bg-gray-50"><tr>{["Idx", "Name", "Type", "Shot C", "Shot R", `X (${unit})`, `Y (${unit})`, `W`, `H`].map((h, i) => (<th key={i} className="px-3 py-2 text-left text-xs font-medium text-gray-500 whitespace-nowrap">{h}</th>))}</tr></thead><tbody className="bg-white divide-y divide-gray-200">{dies.map((d, i) => (<tr key={i} className={i%2===0 ? 'bg-white' : 'bg-gray-50'}><td className="px-3 py-1 text-xs font-mono text-gray-500">{i+1}</td><td className="px-3 py-1 text-xs font-medium">{d.label || 'Single'}</td><td className="px-3 py-1 text-xs capitalize"><span className={`px-1.5 rounded ${d.status==='good'?'bg-emerald-100 text-emerald-800': d.status==='edge'?'bg-orange-100 text-orange-800':'bg-slate-200 text-slate-800'}`}>{d.status}</span></td><td className="px-3 py-1 text-xs font-mono">{d.shotC}</td><td className="px-3 py-1 text-xs font-mono">{d.shotR}</td><td className="px-3 py-1 text-xs font-mono">{d.x.toFixed(3)}</td><td className="px-3 py-1 text-xs font-mono">{d.y.toFixed(3)}</td><td className="px-3 py-1 text-xs font-mono">{d.w.toFixed(3)}</td><td className="px-3 py-1 text-xs font-mono">{d.h.toFixed(3)}</td></tr>))}</tbody></table></div>
                </Modal>
            );
        };

        const WaferCalculator = () => {
            // -- State --
            const [mode, setMode] = useState('single'); 
            const [unit, setUnit] = useState('mm'); 
            const [showLabels, setShowLabels] = useState(false); 
            const [mapBgColor, setMapBgColor] = useState('#0f172a');
            const [defectDensity, setDefectDensity] = useState(0); 
            const [defectSeed, setDefectSeed] = useState(42); 
            const [gdsLayers, setGdsLayers] = useState({ wafer: 0, good: 1, edge: 2, defect: 3, shot: 10, center: 100 });
            const [showShotGrid, setShowShotGrid] = useState(true); 
            const [waferParams, setWaferParams] = useState({ diameter: '150', edgeExclusion: '3', type: 'notch', flatLength: '0', orientation: '0' }); 
            const [singleParams, setSingleParams] = useState({ width: '10', height: '10', scribe: '0.1', offsetMode: 'center', offsetX: '0', offsetY: '0' });
            const [singleDieSettings, setSingleDieSettings] = useState({ colorIdx: 0, customColor: null, borderColor: '#1d4ed8', borderWidth: 0.5 });
            const [shotGridConfig, setShotGridConfig] = useState({ color: '#3b82f6', style: 'dashed', width: 1.5 });
            const [shotParams, setShotParams] = useState({ width: '20', height: '20', scribeX: '0', scribeY: '0', offsetMode: 'center', offsetX: '0', offsetY: '0' });
            const [dieDefinitions, setDieDefinitions] = useState([
                { id: 1, label: 'Main', width: '3', height: '3', offsetX: '0', offsetY: '0', rows: 6, cols: 6, gapX: 0.1, gapY: 0.1, colorIdx: 0, customColor: null, borderColor: '#1d4ed8', borderWidth: 0.5 },
                { id: 2, label: 'Test', width: '1', height: '1', offsetX: '0', offsetY: '0', rows: 2, cols: 2, gapX: 18, gapY: 18, colorIdx: 3, customColor: null, borderColor: '#a16207', borderWidth: 0.5 },
            ]);
            const [stats, setStats] = useState({ summary: [], totalValid: 0, totalEdge: 0, totalDefect: 0, grossShots: 0, utilization: 0, isHighDensity: false, isTooHeavy: false });
            const [viewTransform, setViewTransform] = useState({ k: 1, x: 0, y: 0 });
            
            // -- Interaction State --
            const [activeColorPicker, setActiveColorPicker] = useState(null); 
            const [selectedDie, setSelectedDie] = useState(null); 
            const [popupPosition, setPopupPosition] = useState({ top: 0, left: 0 });
            const [showDieListModalLabel, setShowDieListModalLabel] = useState(null);
            const [showLayerModal, setShowLayerModal] = useState(false);
            const [isDragging, setIsDragging] = useState(false);
            
            // -- New Manager States --
            const [showSaveModal, setShowSaveModal] = useState(false);
            const [showManager, setShowManager] = useState(false);
            const [currentProjectId, setCurrentProjectId] = useState(null); // Currently loaded project ID

            // -- Refs --
            const lastMouseRef = useRef({ x: 0, y: 0 });
            const dragStartRef = useRef({ x: 0, y: 0 });
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const calculatedDataRef = useRef({ dies: [], shots: [], waferR: 0, validR: 0, waferPoly: [], validPoly: [] });
            const calculateAndDrawRef = useRef(null);

            // -- Helpers --
            const parseDim = (val) => { const num = parseFloat(val) || 0; return unit === 'mm' ? num : num / 1000; };
            const parseNum = (val) => parseFloat(val) || 0;
            const labelWithUnit = (key) => { const uStr = unit === 'mm' ? '(mm)' : '(μm)'; return `${T[key]||key} ${uStr}`; };
            const pseudoRandom = (x, y, seed) => { const s = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453; return s - Math.floor(s); };

            // -- Handlers --
            const resetView = () => { setViewTransform({ k: 1, x: 0, y: 0 }); };

            const handleUnitSwitch = (newUnit) => {
                if (newUnit === unit) return;
                const factor = newUnit === 'um' ? 1000 : 0.001; 
                [setSingleParams, setShotParams].forEach(setter => setter(prev => ({ ...prev, width: (parseFloat(prev.width)*factor).toFixed(4), height: (parseFloat(prev.height)*factor).toFixed(4), offsetX: (parseFloat(prev.offsetX)*factor).toFixed(4), offsetY: (parseFloat(prev.offsetY)*factor).toFixed(4) })));
                setSingleParams(p => ({...p, scribe: (parseFloat(p.scribe)*factor).toFixed(4) }));
                setShotParams(p => ({...p, scribeX: (parseFloat(p.scribeX)*factor).toFixed(4), scribeY: (parseFloat(p.scribeY)*factor).toFixed(4) }));
                setDieDefinitions(prev => prev.map(d => ({ ...d, width: (parseFloat(d.width)*factor).toFixed(4), height: (parseFloat(d.height)*factor).toFixed(4), offsetX: (parseFloat(d.offsetX)*factor).toFixed(4), offsetY: (parseFloat(d.offsetY)*factor).toFixed(4), gapX: (parseFloat(d.gapX)*factor).toFixed(4), gapY: (parseFloat(d.gapY)*factor).toFixed(4) })));
                setUnit(newUnit);
            };

            const handleSaveProject = async (metaInfo) => {
                // 1. Generate Thumbnail
                const canvas = canvasRef.current;
                const thumbnail = canvas ? canvas.toDataURL('image/jpeg', 0.5) : '';

                // 2. Collect State
                const state = {
                    mode, unit, showLabels, mapBgColor, defectDensity, defectSeed, gdsLayers,
                    showShotGrid, waferParams, singleParams, singleDieSettings, shotGridConfig,
                    shotParams, dieDefinitions, viewTransform
                };

                // 3. Collect Meta for Quick View
                const dieSizeStr = mode==='single' ? `${singleParams.width}x${singleParams.height}` : `${shotParams.width}x${shotParams.height}`;
                const meta = {
                    waferSize: waferParams.diameter,
                    waferType: waferParams.type,
                    mode: mode,
                    dieSize: dieSizeStr,
                    exclusion: waferParams.edgeExclusion,
                    goodDie: stats.totalValid,
                    yield: stats.utilization.toFixed(2) + '%'
                };

                const projectData = {
                    name: metaInfo.name,
                    folderPath: metaInfo.folderPath,
                    updatedAt: Date.now(),
                    thumbnail,
                    meta,
                    state
                };
                
                // If updating existing? (Optional logic: currently always new entry or overwrite if we track ID)
                // For simplicity, add as new or update if name collision? Let's add new.
                if (currentProjectId) {
                     // Could update existing, but folder path might change. 
                     // Let's just Add new for now to keep history or simple logic.
                     // Or put(id) to update. 
                }
                
                await db.projects.add(projectData);
                setShowSaveModal(false);
                alert("Project saved successfully!");
            };

            const handleLoadProject = (project) => {
                const s = project.state;
                if (!s) return;
                // Batch Restore
                setMode(s.mode); setUnit(s.unit); setShowLabels(s.showLabels); setMapBgColor(s.mapBgColor);
                setDefectDensity(s.defectDensity); setDefectSeed(s.defectSeed); setGdsLayers(s.gdsLayers);
                setShowShotGrid(s.showShotGrid); setWaferParams(s.waferParams); setSingleParams(s.singleParams);
                setSingleDieSettings(s.singleDieSettings); setShotGridConfig(s.shotGridConfig);
                setShotParams(s.shotParams); setDieDefinitions(s.dieDefinitions);
                setViewTransform(s.viewTransform || {k:1,x:0,y:0});
                
                setCurrentProjectId(project.id);
                setShowManager(false);
            };

            const handleWaferChange = (key, val) => {
                if (key === 'diameter') {
                    const d = parseInt(val);
                    let fl = '0'; if (d === 100) fl = '30'; else if (d === 150) fl = '47.5';
                    setWaferParams(p => ({ ...p, diameter: val, flatLength: (p.type === 'flat' && fl !== '0') ? fl : p.flatLength }));
                } else if (key === 'type') {
                     setWaferParams(p => {
                        let fl = p.flatLength; if (val === 'flat') { const d = parseInt(p.diameter); if (d === 100) fl = '30'; else if (d === 150) fl = '47.5'; }
                        return { ...p, type: val, flatLength: fl };
                     });
                } else { setWaferParams(p => ({ ...p, [key]: val })); }
            };
            const updateDieDef = (id, field, val) => setDieDefinitions(prev => prev.map(d => d.id === id ? { ...d, [field]: val } : d));
            
            // Styles
            const handlePresetSelect = (id, idx) => {
                if (id === 'single') setSingleDieSettings(s => ({ ...s, colorIdx: idx, customColor: null, borderColor: PRESET_COLORS[idx].stroke }));
                else if (id === 'shotGrid') setShotGridConfig(s => ({ ...s, color: PRESET_COLORS[idx].stroke }));
                else setDieDefinitions(prev => prev.map(d => d.id === id ? { ...d, colorIdx: idx, customColor: null, borderColor: PRESET_COLORS[idx].stroke } : d));
            };
            const handleCustomColorSelect = (id, hex) => {
                if (id === 'single') setSingleDieSettings(s => ({ ...s, colorIdx: 0, customColor: hex }));
                else if (id === 'shotGrid') setShotGridConfig(s => ({ ...s, color: hex }));
                else setDieDefinitions(prev => prev.map(d => d.id === id ? { ...d, customColor: hex } : d));
            };
            const handleBorderColorSelect = (id, hex) => {
                if (id === 'single') setSingleDieSettings(s => ({ ...s, borderColor: hex }));
                else if (id === 'shotGrid') setShotGridConfig(s => ({ ...s, color: hex }));
                else setDieDefinitions(prev => prev.map(d => d.id === id ? { ...d, borderColor: hex } : d));
            };
            const handleBorderWidthChange = (id, val) => {
                 const v = parseFloat(val)||0.5;
                 if (id === 'single') setSingleDieSettings(s => ({ ...s, borderWidth: v }));
                 else if (id === 'shotGrid') setShotGridConfig(s => ({ ...s, width: v }));
                 else setDieDefinitions(prev => prev.map(d => d.id === id ? { ...d, borderWidth: v } : d));
            };

            // Canvas Drawing & Interactions
            const handleWheel = (e) => { e.preventDefault(); if (stats.isHighDensity || stats.isTooHeavy) return; const rect = canvasRef.current.getBoundingClientRect(); const mx = e.clientX - rect.left - rect.width/2; const my = e.clientY - rect.top - rect.height/2; const factor = e.deltaY < 0 ? 1.1 : 0.9; const newK = Math.max(0.1, Math.min(viewTransform.k * factor, 50)); const ratio = newK / viewTransform.k; setViewTransform({ k: newK, x: mx - (mx - viewTransform.x) * ratio, y: my - (my - viewTransform.y) * ratio }); };
            const handleMouseDown = (e) => { if (stats.isHighDensity || stats.isTooHeavy) return; setIsDragging(true); lastMouseRef.current = { x: e.clientX, y: e.clientY }; dragStartRef.current = { x: e.clientX, y: e.clientY }; };
            const handleMouseMove = (e) => { if (!isDragging) return; const dx = e.clientX - lastMouseRef.current.x; const dy = e.clientY - lastMouseRef.current.y; lastMouseRef.current = { x: e.clientX, y: e.clientY }; setViewTransform(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy })); };
            const handleMouseUp = (e) => { setIsDragging(false); const dist = Math.sqrt(Math.pow(e.clientX - dragStartRef.current.x, 2) + Math.pow(e.clientY - dragStartRef.current.y, 2)); if (dist < 5) handleCanvasClick(e); };
            const handleCanvasClick = (e) => { if (!canvasRef.current || stats.isHighDensity || stats.isTooHeavy) return; const rect = canvasRef.current.getBoundingClientRect(); const displaySizeW = containerRef.current.clientWidth; const displaySizeH = containerRef.current.clientHeight; const waferD = parseNum(waferParams.diameter); const R = waferD/2; const baseScale = (Math.min(displaySizeW, displaySizeH)/2)/(R*1.05); const finalScale = baseScale * viewTransform.k; const mx = e.clientX - rect.left - (displaySizeW/2 + viewTransform.x); const my = e.clientY - rect.top - (displaySizeH/2 + viewTransform.y); const worldX = mx/finalScale; const worldY = -my/finalScale; const clickedDie = calculatedDataRef.current.dies.find(d => worldX >= d.x - d.w/2 && worldX <= d.x + d.w/2 && worldY >= d.y - d.h/2 && worldY <= d.y + d.h/2); if (clickedDie) { if (selectedDie && selectedDie.x === clickedDie.x && selectedDie.y === clickedDie.y) setSelectedDie(null); else setSelectedDie(clickedDie); } else setSelectedDie(null); };

            useEffect(() => {
                const handleKeyDown = (e) => { if (e.key === 'Escape') setSelectedDie(null); }; const handleContextMenu = (e) => { if (e.target === canvasRef.current) setSelectedDie(null); }; window.addEventListener('keydown', handleKeyDown); document.addEventListener('contextmenu', handleContextMenu); return () => { window.removeEventListener('keydown', handleKeyDown); document.removeEventListener('contextmenu', handleContextMenu); }
            }, []);
            useEffect(() => { if (selectedDie && containerRef.current) { const container = containerRef.current; const displaySizeW = container.clientWidth; const displaySizeH = container.clientHeight; const waferD = parseNum(waferParams.diameter); const R = waferD/2; const baseScale = (Math.min(displaySizeW, displaySizeH)/2)/(R*1.05); const finalScale = baseScale * viewTransform.k; const screenX = (selectedDie.x * finalScale) + (displaySizeW/2 + viewTransform.x); const screenY = (selectedDie.y * -finalScale) + (displaySizeH/2 + viewTransform.y); setPopupPosition({ left: screenX, top: screenY }); } }, [selectedDie, viewTransform, waferParams]);

            // Main Render Loop
            const calculateAndDraw = () => {
                const canvas = canvasRef.current; const container = containerRef.current; if (!canvas || !container) return;
                const dpr = window.devicePixelRatio || 1; const displaySizeW = container.clientWidth; const displaySizeH = container.clientHeight;
                if (canvas.width !== displaySizeW * dpr || canvas.height !== displaySizeH * dpr) { canvas.width = displaySizeW * dpr; canvas.height = displaySizeH * dpr; }
                const ctx = canvas.getContext('2d'); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.scale(dpr, dpr); ctx.clearRect(0, 0, displaySizeW, displaySizeH);
                
                const waferD = parseNum(waferParams.diameter); const R = waferD / 2; const exclusion = parseNum(waferParams.edgeExclusion); const validR = Math.max(0, R - exclusion); const orientationDeg = parseNum(waferParams.orientation); const rotRad = orientationDeg * Math.PI / 180;
                ctx.translate(displaySizeW / 2 + viewTransform.x, displaySizeH / 2 + viewTransform.y); const baseScale = (Math.min(displaySizeW, displaySizeH) / 2) / (R * 1.05); const finalScale = baseScale * viewTransform.k; ctx.scale(finalScale, -finalScale);

                const generateWaferOutline = (radius, type, specValue, rotationDeg = 0) => { const points = []; const steps = 360; const rRad = rotationDeg * Math.PI / 180; const rotate = (p) => ({ x: p.x * Math.cos(rRad) - p.y * Math.sin(rRad), y: p.x * Math.sin(rRad) + p.y * Math.cos(rRad) }); if (type === 'flat') { const flatLength = parseNum(specValue); if (flatLength <= 0 || flatLength >= radius * 2) return generateCircle(radius).map(rotate); const alpha = Math.asin((flatLength / 2) / radius); const arcSteps = 100; const startRad = -Math.PI/2 + alpha; const endRad = 1.5*Math.PI - alpha; for(let i=0; i<=arcSteps; i++) { const t = startRad + (endRad - startRad) * (i/arcSteps); points.push(rotate({ x: radius * Math.cos(t), y: radius * Math.sin(t) })); } return points; } else if (type === 'notch') { const notchD = 1.5; const notchW = 3; for(let i=0; i<=steps; i++) { const theta = (i/steps)*2*Math.PI; if (Math.abs(theta - 1.5*Math.PI) < 0.03) { if (points[points.length-1]?.isNotch) continue; points.push(rotate({ x: -notchW/2, y: -radius, isNotch: true })); points.push(rotate({ x: 0, y: -radius + notchD })); points.push(rotate({ x: notchW/2, y: -radius })); } else { points.push(rotate({ x: radius * Math.cos(theta), y: radius * Math.sin(theta) })); } } return points; } return generateCircle(radius).map(rotate); };
                const generateCircle = (r) => { const p = []; for(let i=0; i<=128; i++) { const t = (i/128)*2*Math.PI; p.push({x: r*Math.cos(t), y: r*Math.sin(t)}); } return p; };
                
                const waferPoly = generateWaferOutline(R, waferParams.type, waferParams.flatLength, orientationDeg); const validPoly = generateWaferOutline(validR, waferParams.type, waferParams.flatLength, orientationDeg);
                ctx.beginPath(); waferPoly.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y)); ctx.closePath(); ctx.fillStyle = '#f8fafc'; ctx.fill(); ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 1.5 / finalScale; ctx.stroke();
                ctx.beginPath(); if (waferParams.type === 'flat') { validPoly.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y)); } else { ctx.arc(0, 0, validR, 0, 2 * Math.PI); } ctx.closePath(); ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 1 / finalScale; ctx.setLineDash([5 / finalScale, 3 / finalScale]); ctx.stroke(); ctx.setLineDash([]);
                
                if (waferParams.type === 'notch') {
                    const notchAngle = -Math.PI/2 + rotRad; const fontSize = 15 / finalScale; const arrowLength = 20 / finalScale; const tipR = R + (1/finalScale); const tailR = tipR + arrowLength; const textR = tailR + 2/finalScale + (fontSize/2); const tipX = tipR * Math.cos(notchAngle); const tipY = tipR * Math.sin(notchAngle); const tailX = tailR * Math.cos(notchAngle); const tailY = tailR * Math.sin(notchAngle); const textX = textR * Math.cos(notchAngle); const textY = textR * Math.sin(notchAngle);
                    ctx.save(); ctx.strokeStyle = '#64748b'; ctx.fillStyle = '#64748b'; ctx.lineWidth = 1 / finalScale; ctx.beginPath(); ctx.moveTo(tailX, tailY); ctx.lineTo(tipX, tipY); ctx.stroke();
                    const headLen = 4 / finalScale; const headAngle = Math.PI / 6; const arrowDir = notchAngle + Math.PI; ctx.beginPath(); ctx.moveTo(tipX, tipY); ctx.lineTo(tipX + headLen * Math.cos(arrowDir - headAngle), tipY + headLen * Math.sin(arrowDir - headAngle)); ctx.lineTo(tipX + headLen * Math.cos(arrowDir + headAngle), tipY + headLen * Math.sin(arrowDir + headAngle)); ctx.closePath(); ctx.fill();
                    ctx.translate(textX, textY); ctx.scale(1, -1); ctx.font = `italic ${fontSize}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("Notch", 0, 0); ctx.restore();
                }

                let layoutStepX, layoutStepY, startOffX, startOffY, shotW, shotH;
                if (mode === 'single') { shotW = parseDim(singleParams.width); shotH = parseDim(singleParams.height); layoutStepX = shotW + parseDim(singleParams.scribe); layoutStepY = shotH + parseDim(singleParams.scribe); startOffX = (singleParams.offsetMode === 'vertex' ? layoutStepX / 2 : 0) + parseDim(singleParams.offsetX); startOffY = (singleParams.offsetMode === 'vertex' ? layoutStepY / 2 : 0) + parseDim(singleParams.offsetY); } 
                else { shotW = parseDim(shotParams.width); shotH = parseDim(shotParams.height); layoutStepX = shotW + parseDim(shotParams.scribeX); layoutStepY = shotH + parseDim(shotParams.scribeY); startOffX = (shotParams.offsetMode === 'vertex' ? layoutStepX / 2 : 0) + parseDim(shotParams.offsetX); startOffY = (shotParams.offsetMode === 'vertex' ? layoutStepY / 2 : 0) + parseDim(shotParams.offsetY); }
                if (layoutStepX <= 0.000001 || layoutStepY <= 0.000001) return;

                const maxCol = Math.ceil(R / layoutStepX) + 1; const maxRow = Math.ceil(R / layoutStepY) + 1;
                if ((maxCol * 2) * (maxRow * 2) > 2000000) { setStats(prev => ({ ...prev, isTooHeavy: true, isHighDensity: false })); return; }
                
                const isHighDensity = layoutStepX < 0.1 || layoutStepY < 0.1;
                const allDies = []; const allShots = []; let grossShots = 0; let hdTotalValid = 0; let hdTotalEdge = 0; let hdTotalDieArea = 0; const hdSummary = {}; const cosR = Math.cos(-rotRad); const sinR = Math.sin(-rotRad);
                let gridMinX = Infinity, gridMaxX = -Infinity, gridMinY = Infinity, gridMaxY = -Infinity;

                for (let col = -maxCol; col <= maxCol; col++) {
                    for (let row = -maxRow; row <= maxRow; row++) {
                        const gridCenterX = col * layoutStepX + startOffX; const gridCenterY = row * layoutStepY + startOffY;
                        if (Math.sqrt(gridCenterX**2 + gridCenterY**2) > R + Math.max(layoutStepX, layoutStepY)) continue;
                        const shotCorners = [ {x: gridCenterX - shotW/2, y: gridCenterY - shotH/2}, {x: gridCenterX + shotW/2, y: gridCenterY - shotH/2}, {x: gridCenterX + shotW/2, y: gridCenterY + shotH/2}, {x: gridCenterX - shotW/2, y: gridCenterY + shotH/2}, ];
                        let isShotPartial = false; for(let c of shotCorners) if (Math.sqrt(c.x**2 + c.y**2) <= R) isShotPartial = true; if (!isShotPartial && Math.sqrt(gridCenterX**2 + gridCenterY**2) < Math.max(shotW, shotH)/2) isShotPartial = true;
                        if (isShotPartial) { grossShots++; allShots.push({ x: gridCenterX, y: gridCenterY, w: shotW, h: shotH }); gridMinX = Math.min(gridMinX, col); gridMaxX = Math.max(gridMaxX, col); gridMinY = Math.min(gridMinY, row); gridMaxY = Math.max(gridMaxY, row); }
                        
                        let dieGroups = [];
                        if (mode === 'single') { dieGroups.push({ typeId: 0, label: 'Single', w: shotW, h: shotH, relX: 0, relY: 0, rows: 1, cols: 1, gapX: 0, gapY: 0, colorIdx: singleDieSettings.colorIdx, customColor: singleDieSettings.customColor, borderColor: singleDieSettings.borderColor, borderWidth: singleDieSettings.borderWidth, shotC: col, shotR: -row }); } 
                        else { dieGroups = dieDefinitions.map(d => ({ typeId: d.id, label: d.label, w: parseDim(d.width), h: parseDim(d.height), relX: parseDim(d.offsetX), relY: parseDim(d.offsetY), rows: parseNum(d.rows) || 1, cols: parseNum(d.cols) || 1, gapX: parseDim(d.gapX) || 0, gapY: parseDim(d.gapY) || 0, colorIdx: d.colorIdx, customColor: d.customColor, borderColor: d.borderColor, borderWidth: d.borderWidth, shotC: col, shotR: -row })); }
                        dieGroups.forEach(group => {
                            const totalArrW = group.cols * group.w + (group.cols - 1) * group.gapX; const totalArrH = group.rows * group.h + (group.rows - 1) * group.gapY; const startX = -totalArrW / 2 + group.w / 2; const startY = -totalArrH / 2 + group.h / 2;
                            for(let r = 0; r < group.rows; r++) { for(let c = 0; c < group.cols; c++) {
                                    const arrOffsetX = startX + c * (group.w + group.gapX); const arrOffsetY = startY + r * (group.h + group.gapY); const dieCenterX = gridCenterX + group.relX + arrOffsetX; const dieCenterY = gridCenterY + group.relY + arrOffsetY;
                                    const corners = [ { x: dieCenterX - group.w/2, y: dieCenterY - group.h/2 }, { x: dieCenterX + group.w/2, y: dieCenterY - group.h/2 }, { x: dieCenterX + group.w/2, y: dieCenterY + group.h/2 }, { x: dieCenterX - group.w/2, y: dieCenterY + group.h/2 } ];
                                    let isPhysicallyInside = true; let isEffectivelyInside = true;
                                    for (let cr of corners) { const d = Math.sqrt(cr.x**2 + cr.y**2); if (d > R) { isPhysicallyInside = false; isEffectivelyInside = false; break; } if (waferParams.type === 'flat') { const flatLen = parseNum(waferParams.flatLength); const flatH = Math.sqrt(R*R - (flatLen/2)**2); const ry = cr.x * sinR + cr.y * cosR; if (ry < -flatH) { isPhysicallyInside = false; isEffectivelyInside = false; break; } } if (d > validR) isEffectivelyInside = false; if (waferParams.type === 'flat') { const flatLen = parseNum(waferParams.flatLength); const flatH = Math.sqrt(R*R - (flatLen/2)**2); const ry = cr.x * sinR + cr.y * cosR; if (ry < -(flatH - exclusion)) isEffectivelyInside = false; } }
                                    if (isPhysicallyInside) { 
                                        let status = isEffectivelyInside ? 'good' : 'edge';
                                        if (status === 'good' && defectDensity > 0) { const area = group.w * group.h; const prob = 1 - Math.exp(-defectDensity * area); const rand = pseudoRandom(dieCenterX, dieCenterY, defectSeed); if (rand < prob) status = 'defect'; }
                                        if (isHighDensity) { if (!hdSummary[group.typeId]) hdSummary[group.typeId] = { label: group.label, valid: 0, edge: 0, defect: 0, color: resolveColor(group.colorIdx, group.customColor) }; if (status === 'good') { hdSummary[group.typeId].valid++; hdTotalValid++; hdTotalDieArea += (group.w * group.h); } else if (status === 'defect') { hdSummary[group.typeId].defect++; } else { hdSummary[group.typeId].edge++; hdTotalEdge++; } } 
                                        else { allDies.push({ ...group, x: dieCenterX, y: dieCenterY, status: status }); }
                                    }
                            }}
                        });
                    }
                }

                if (isHighDensity) { const waferArea = Math.PI * R * R; setStats({ summary: Object.values(hdSummary), totalValid: hdTotalValid, totalEdge: hdTotalEdge, totalDefect: 0, grossShots, utilization: waferArea > 0 ? (hdTotalDieArea / waferArea * 100) : 0, isHighDensity: true, isTooHeavy: false }); } 
                else {
                    calculatedDataRef.current = { dies: allDies, shots: allShots, waferR: R, validR, waferPoly, validPoly }; 
                    const summaryMap = {}; let totalValid = 0; let totalEdge = 0; let totalDefect = 0; let totalDieArea = 0;
                    allDies.forEach(d => { if (!summaryMap[d.typeId]) { const def = mode === 'single' ? { label: 'Single Die' } : dieDefinitions.find(x => x.id === d.typeId); const resolvedColor = resolveColor(d.colorIdx, d.customColor); summaryMap[d.typeId] = { label: def ? def.label : 'Unknown', valid: 0, edge: 0, defect: 0, color: resolvedColor }; } if (d.status === 'good') { summaryMap[d.typeId].valid++; totalValid++; totalDieArea += (d.w * d.h); } else if (d.status === 'defect') { summaryMap[d.typeId].defect++; totalDefect++; } else { summaryMap[d.typeId].edge++; totalEdge++; } });
                    const waferArea = Math.PI * R * R; setStats({ summary: Object.values(summaryMap), totalValid, totalEdge, totalDefect, grossShots, utilization: waferArea > 0 ? (totalDieArea / waferArea * 100) : 0, isHighDensity: false, isTooHeavy: false });
                    allDies.forEach(d => { let fillStyle, strokeStyle; if (d.status === 'defect') { fillStyle = DEFECT_COLOR.fill; strokeStyle = DEFECT_COLOR.stroke; } else { const colorDef = resolveColor(d.colorIdx, d.customColor); fillStyle = d.status === 'good' ? colorDef.fill : colorDef.fill + '60'; strokeStyle = d.status === 'good' ? (d.borderColor || colorDef.stroke) : '#ea580c'; } const lw = (d.status === 'good' ? (d.borderWidth || 0.5) : 1) / finalScale; ctx.beginPath(); ctx.rect(d.x - d.w/2, d.y - d.h/2, d.w, d.h); ctx.fillStyle = fillStyle; ctx.fill(); ctx.strokeStyle = strokeStyle; ctx.lineWidth = lw; ctx.stroke(); if (selectedDie && d.x === selectedDie.x && d.y === selectedDie.y) { ctx.strokeStyle = '#06b6d4'; ctx.lineWidth = 3 / finalScale; ctx.stroke(); } if (showLabels && (d.status === 'good' || d.status === 'defect')) { ctx.save(); ctx.translate(d.x, d.y); ctx.scale(1, -1); ctx.fillStyle = d.status === 'defect' ? '#f1f5f9' : '#111827'; const fs = Math.min(d.w, d.h) * 0.5; if (fs * finalScale > 6) { ctx.font = `${fs}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const labelText = (mode === 'single') ? `${d.shotC},${d.shotR}` : (d.label || ''); ctx.fillText(labelText, 0, 0); } ctx.restore(); } });
                    if (mode === 'shot' && showShotGrid) { ctx.strokeStyle = shotGridConfig.color; ctx.lineWidth = (shotGridConfig.width || 1.5) / finalScale; if (shotGridConfig.style === 'dashed') ctx.setLineDash([8 / finalScale, 4 / finalScale]); else ctx.setLineDash([]); allShots.forEach(s => { ctx.beginPath(); ctx.rect(s.x - s.w/2, s.y - s.h/2, s.w, s.h); ctx.stroke(); }); ctx.setLineDash([]); }
                    if (showLabels) { const gridExtentRight = (gridMaxX !== -Infinity) ? (gridMaxX * layoutStepX + startOffX + layoutStepX/2) : R; const gridExtentTop = (gridMaxY !== -Infinity) ? (gridMaxY * layoutStepY + startOffY + layoutStepY/2) : R; const gridExtentLeft = (gridMinX !== Infinity) ? (gridMinX * layoutStepX + startOffX - layoutStepX/2) : -R; const safeRight = Math.max(R, gridExtentRight) + 5; const safeTop = Math.max(R, gridExtentTop) + 5; const safeLeft = Math.min(-R, gridExtentLeft) - 5; const tickSize = 5 / finalScale; ctx.save(); ctx.lineWidth = 1 / finalScale; ctx.strokeStyle = '#64748b'; ctx.fillStyle = '#64748b'; ctx.font = `${12/finalScale}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; if (gridMinX !== Infinity && gridMaxX !== -Infinity) { const axisStartX = gridMinX * layoutStepX + startOffX - layoutStepX/2; const axisEndX = gridMaxX * layoutStepX + startOffX + layoutStepX/2; ctx.beginPath(); ctx.moveTo(axisStartX, safeTop); ctx.lineTo(axisEndX, safeTop); ctx.stroke(); for(let c = gridMinX; c <= gridMaxX; c++) { const tx = c * layoutStepX + startOffX; const tickX = tx - layoutStepX / 2; ctx.beginPath(); ctx.moveTo(tickX, safeTop); ctx.lineTo(tickX, safeTop + tickSize); ctx.stroke(); if (c === gridMaxX) { const endTickX = tx + layoutStepX / 2; ctx.beginPath(); ctx.moveTo(endTickX, safeTop); ctx.lineTo(endTickX, safeTop + tickSize); ctx.stroke(); } ctx.save(); ctx.translate(tx, safeTop + tickSize*3); ctx.scale(1, -1); ctx.fillText(`${c}`, 0, 0); ctx.restore(); } } if (gridMinY !== Infinity && gridMaxY !== -Infinity) { const axisStartY = gridMinY * layoutStepY + startOffY - layoutStepY/2; const axisEndY = gridMaxY * layoutStepY + startOffY + layoutStepY/2; ctx.beginPath(); ctx.moveTo(safeLeft, axisStartY); ctx.lineTo(safeLeft, axisEndY); ctx.stroke(); for(let r = gridMinY; r <= gridMaxY; r++) { const ty = r * layoutStepY + startOffY; const tickY = ty - layoutStepY / 2; ctx.beginPath(); ctx.moveTo(safeLeft, tickY); ctx.lineTo(safeLeft - tickSize, tickY); ctx.stroke(); if (r === gridMaxY) { const endTickY = ty + layoutStepY / 2; ctx.beginPath(); ctx.moveTo(safeLeft, endTickY); ctx.lineTo(safeLeft - tickSize, endTickY); ctx.stroke(); } ctx.save(); ctx.translate(safeLeft - tickSize*4, ty); ctx.scale(1, -1); ctx.fillText(`${-r}`, 0, 0); ctx.restore(); } } ctx.restore(); }
                }
                const extLen = R + (2 * R * 0.1); ctx.beginPath(); ctx.moveTo(-extLen, 0); ctx.lineTo(extLen, 0); ctx.moveTo(0, -extLen); ctx.lineTo(0, extLen); ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 1 / finalScale; ctx.stroke();
            };
            calculateAndDrawRef.current = calculateAndDraw;
            useEffect(() => { const resizeObserver = new ResizeObserver(() => window.requestAnimationFrame(() => calculateAndDrawRef.current && calculateAndDrawRef.current())); if (containerRef.current) resizeObserver.observe(containerRef.current); return () => resizeObserver.disconnect(); }, []);
            useEffect(() => { calculateAndDraw(); }, [waferParams, singleParams, shotParams, dieDefinitions, mode, showShotGrid, singleDieSettings, shotGridConfig, viewTransform, unit, showLabels, selectedDie, defectDensity, defectSeed]);

            const handleExportGDS = () => { /* ... existing GDS export logic ... */ if (stats.isHighDensity || stats.isTooHeavy) { alert("GDS Export is disabled in High Density Mode."); return; } const { dies, shots, waferR, validR, waferPoly, validPoly } = calculatedDataRef.current; const writer = new GDSWriter(); const unitScale = 1000000; writer.writeHeader(); writer.writeBgnLib(); writer.writeLibName("WAFER_MAP_LIB"); writer.writeUnits(); writer.writeBgnStr("WAFER_TOP"); const toGdsPoints = (poly) => { const pts = []; poly.forEach(p => pts.push(Math.round(p.x * unitScale), Math.round(p.y * unitScale))); return pts; }; if (waferPoly && waferPoly.length > 0) writer.writeBoundary(gdsLayers.wafer, 0, toGdsPoints(waferPoly)); const cSize = waferR + (2 * waferR * 0.1); const cW = 0.1; writer.writePath(gdsLayers.center, 0, Math.round(cW*unitScale), [Math.round(-cSize*unitScale), 0, Math.round(cSize*unitScale), 0]); writer.writePath(gdsLayers.center, 0, Math.round(cW*unitScale), [0, Math.round(-cSize*unitScale), 0, Math.round(cSize*unitScale), 0]); if (mode === 'shot') { shots.forEach(s => { const x1 = Math.round((s.x - s.w/2) * unitScale); const y1 = Math.round((s.y - s.h/2) * unitScale); const x2 = Math.round((s.x + s.w/2) * unitScale); const y2 = Math.round((s.y + s.h/2) * unitScale); writer.writeBoundary(gdsLayers.shot, 0, [x1, y1, x2, y1, x2, y2, x1, y2, x1, y1]); }); } dies.forEach(d => { let layer; if (d.status === 'good') layer = gdsLayers.good; else if (d.status === 'defect') layer = gdsLayers.defect; else layer = gdsLayers.edge; const x1 = Math.round((d.x - d.w/2) * unitScale); const y1 = Math.round((d.y - d.h/2) * unitScale); const x2 = Math.round((d.x + d.w/2) * unitScale); const y2 = Math.round((d.y + d.h/2) * unitScale); writer.writeBoundary(layer, d.typeId, [x1, y1, x2, y1, x2, y2, x1, y2, x1, y1]); }); writer.writeEndStr(); writer.writeEndLib(); const blob = writer.getBlob(); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `wafer_map_${waferParams.diameter}mm.gds`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); };
            const handleExportExcel = () => { /* ... existing Excel export logic ... */ if (typeof XLSX === 'undefined') { alert("Excel library not loaded properly. Please check your internet connection."); return; } const wb = XLSX.utils.book_new(); const uStr = unit==='mm'?' mm':' um'; const infoRows = [ ["Parameter", "Value"], ["Wafer Diameter", waferParams.diameter + " mm"], ["Wafer Type", waferParams.type], ["Orientation", waferParams.orientation + "°"], ["Edge Exclusion", waferParams.edgeExclusion + " mm"], ["Total Good Die", stats.totalValid], ["Total Defect Die", stats.totalDefect], ["Total Edge Die", stats.totalEdge], ["Defect Density", defectDensity + " /mm²"], ["Utilization", stats.utilization.toFixed(2) + "%"], ["Mode", mode === 'single' ? "Single Die" : "Multi Die (MPW)"], ]; if (waferParams.type === 'flat') { infoRows.splice(4, 0, ["Flat Length", waferParams.flatLength + " mm"]); } if (mode === 'single') { infoRows.push( ["Die Width", singleParams.width + uStr], ["Die Height", singleParams.height + uStr], ["Scribe", singleParams.scribe + uStr], ["Grid Offset X", singleParams.offsetX + uStr], ["Grid Offset Y", singleParams.offsetY + uStr] ); } else { infoRows.push( ["Shot Width", shotParams.width + uStr], ["Shot Height", shotParams.height + uStr], ["Shot Offset X", shotParams.offsetX + uStr], ["Shot Offset Y", shotParams.offsetY + uStr], ["Scribe X", shotParams.scribeX + uStr], ["Scribe Y", shotParams.scribeY + uStr] ); infoRows.push(["", ""], ["Defined Die Groups", ""]); dieDefinitions.forEach(d => { infoRows.push([`Group: ${d.label}`, `${d.width}x${d.height}${uStr}, Array: ${d.rows}x${d.cols}`]); }); } const wsSummary = XLSX.utils.aoa_to_sheet(infoRows); wsSummary['!cols'] = [{ wch: 25 }, { wch: 30 }]; XLSX.utils.book_append_sheet(wb, wsSummary, "Wafer Info"); if (!stats.isTooHeavy && !stats.isHighDensity) { const dies = calculatedDataRef.current.dies; const u = unit==='mm'?'(mm)':'(um)'; const headers = ["Index", "Name", "Type", "Shot Col", "Shot Row", `Center X ${u}`, `Center Y ${u}`, `Width ${u}`, `Height ${u}`]; const dieData = [headers]; dies.forEach((d, i) => { const f = unit === 'um' ? 1000 : 1; dieData.push([ i+1, d.label || 'Single', d.status, d.shotC, d.shotR, (d.x * f).toFixed(3), (d.y * f).toFixed(3), (d.w * f).toFixed(3), (d.h * f).toFixed(3) ]); }); const wsDies = XLSX.utils.aoa_to_sheet(dieData); XLSX.utils.book_append_sheet(wb, wsDies, "Die Coordinates"); } else { const wsInfo = XLSX.utils.aoa_to_sheet([["Note"], ["Die coordinates omitted due to high density (>100k) or calculation limit."]]); XLSX.utils.book_append_sheet(wb, wsInfo, "Info"); } XLSX.writeFile(wb, `WaferCalc_Report_${waferParams.diameter}mm.xlsx`); };
            const renderStylePicker = (id, currentSettings, updateBorderColor, updateBorderWidth, isShotGrid = false) => { return (<div className="relative style-picker-container"><button onClick={() => setActiveColorPicker(activeColorPicker === id ? null : id)} className="w-4 h-4 rounded border border-gray-300 shadow-sm hover:scale-110 transition-transform flex items-center justify-center" style={{ background: isShotGrid ? 'white' : currentSettings.fill }}>{isShotGrid && <div className="w-2.5 h-2.5 rounded-sm" style={{ border: `1px ${currentSettings.style || 'solid'} ${currentSettings.borderColor}` }}></div>}</button>{activeColorPicker === id && (<div className={`absolute ${isShotGrid ? 'right-0' : 'left-0'} top-6 z-50 bg-white border border-gray-200 shadow-xl rounded-lg p-3 w-56 flex flex-col gap-3`}>{!isShotGrid && (<div><div className="text-[10px] text-gray-500 mb-1 font-bold uppercase tracking-wider">Fill Color</div><div className="grid grid-cols-5 gap-2 mb-2">{PRESET_COLORS.map((c, idx) => ( <button key={idx} onClick={() => handlePresetSelect(id, idx)} className="w-6 h-6 rounded-full border border-gray-100 hover:scale-110 transition-transform shadow-sm" style={{ background: c.fill }} title={c.name} /> ))}</div><div className="flex items-center gap-2"><input type="color" value={currentSettings.fill} onChange={(e) => handleCustomColorSelect(id, e.target.value)} className="w-full h-6 cursor-pointer rounded border border-gray-200" /></div></div>)}<div className={!isShotGrid ? "border-t border-gray-100 pt-2" : ""}><div className="text-[10px] text-gray-500 mb-1 font-bold uppercase tracking-wider">{isShotGrid ? "Grid Line Style" : "Border Style"}</div><div className="flex items-center gap-2 mb-2"><span className="text-xs text-gray-600 w-12">Color</span><div className="flex-1 flex gap-1">{isShotGrid && PRESET_COLORS.slice(0,5).map((c, idx) => ( <button key={idx} onClick={() => handlePresetSelect(id, idx)} className="w-4 h-4 rounded-full border border-gray-100 hover:scale-110" style={{ background: c.stroke }} /> ))}<input type="color" value={currentSettings.borderColor || '#000000'} onChange={(e) => handleBorderColorSelect(id, e.target.value)} className="flex-1 h-6 cursor-pointer rounded border border-gray-200" /></div></div><div className="flex items-center gap-2 mb-2"><span className="text-xs text-gray-600 w-12">Width</span><input type="number" step="0.1" value={currentSettings.borderWidth || 0.5} onChange={(e) => handleBorderWidthChange(id, e.target.value)} className="flex-1 h-6 px-1 text-xs border border-gray-300 rounded" /></div>{isShotGrid && (<div className="flex items-center gap-2"><span className="text-xs text-gray-600 w-12">Type</span><select value={currentSettings.style} onChange={(e) => setShotGridConfig(s => ({ ...s, style: e.target.value }))} className="flex-1 h-6 px-1 text-xs border border-gray-300 rounded bg-white"><option value="solid">Solid</option><option value="dashed">Dashed</option></select></div>)}</div></div>)}</div>); };
            const getDiesForModal = (label) => { const dies = calculatedDataRef.current.dies.filter(d => (d.label || 'Single') === label); const f = unit === 'um' ? 1000 : 1; return dies.map(d => ({ ...d, x: d.x * f, y: d.y * f, w: d.w * f, h: d.h * f })); };

            return (
                <div className="flex h-screen w-full overflow-hidden bg-white">
                    <div className="w-[360px] lg:w-[400px] flex-shrink-0 flex flex-col bg-white border-r border-gray-200 shadow-lg z-20">
                        <div className="p-3 border-b border-gray-200 bg-white flex justify-between items-center">
                            <h1 className="text-2xl font-bold text-indigo-700 flex items-center gap-2"><Icons.Disc /> {T.title}</h1>
                            <div className="flex gap-2">
                                <button onClick={() => setShowSaveModal(true)} className="p-1.5 text-gray-400 hover:text-indigo-600 hover:bg-indigo-50 rounded" title="Save Project"><Icons.Save /></button>
                                <button onClick={() => setShowManager(true)} className="bg-indigo-600 hover:bg-indigo-700 text-white text-xs font-bold px-3 py-1.5 rounded flex items-center gap-1 shadow"><Icons.Folder /> Manage</button>
                            </div>
                        </div>
                        <div className="flex-1 overflow-y-auto p-3 space-y-4 custom-scroll bg-gray-50/50">
                            <div className="space-y-2"><h3 className="text-lg font-extrabold text-slate-700 flex items-center gap-2"><Icons.Settings /> {T.waferParams}</h3><div className="bg-white p-2.5 rounded-lg border border-gray-200 shadow-sm"><div className="grid grid-cols-2 gap-2 mb-2"><div><label className="block text-xs font-medium text-gray-500 mb-0.5">{T.size}</label><select value={waferParams.diameter} onChange={(e) => handleWaferChange('diameter', e.target.value)} className="block w-full py-1.5 px-2 border border-gray-300 rounded-md text-sm bg-gray-50 focus:ring-1 focus:ring-indigo-500"><option value="100">4 Inch (100mm)</option><option value="150">6 Inch (150mm)</option><option value="200">8 Inch (200mm)</option><option value="300">12 Inch (300mm)</option></select></div><div><label className="block text-xs font-medium text-gray-500 mb-0.5">{T.waferType}</label><select value={waferParams.type} onChange={(e) => handleWaferChange('type', e.target.value)} className="block w-full py-1.5 px-2 border border-gray-300 rounded-md text-sm bg-gray-50 focus:ring-1 focus:ring-indigo-500"><option value="notch">{T.notch}</option><option value="flat">{T.flat}</option></select></div></div><div className="grid grid-cols-2 gap-2 mb-0"><NumberInput label={T.orientation} value={waferParams.orientation} onChange={(v) => handleWaferChange('orientation', v)} suffix="°" /><NumberInput label={T.exclusion} value={waferParams.edgeExclusion} onChange={(v) => handleWaferChange('edgeExclusion', v)} /></div><div className="flex items-end gap-2 mt-2">{waferParams.type === 'flat' && (<div className="w-[100px]"><NumberInput label={T.flatLength} value={waferParams.flatLength} onChange={(v) => handleWaferChange('flatLength', v)} /></div>)}<div className="flex-1"></div><ViewControls unit={unit} onUnitChange={handleUnitSwitch} showLabels={showLabels} onShowLabelsChange={setShowLabels} bgColor={mapBgColor} onBgColorChange={setMapBgColor} /></div></div></div>
                            <div className="space-y-2"><h3 className="text-lg font-extrabold text-slate-700 flex items-center gap-2"><Icons.Grid /> {T.chipParams}</h3><div className="bg-white p-2.5 rounded-lg border border-gray-200 shadow-sm"><div className="flex bg-gray-100 p-0.5 rounded-md mb-3"><button onClick={() => setMode('single')} className={`flex-1 py-1.5 text-sm font-medium rounded-sm transition-all ${mode === 'single' ? 'bg-white shadow text-indigo-600' : 'text-gray-500 hover:text-gray-700'}`}>{T.singleMode}</button><button onClick={() => setMode('shot')} className={`flex-1 py-1.5 text-sm font-medium rounded-sm transition-all ${mode === 'shot' ? 'bg-white shadow text-indigo-600' : 'text-gray-500 hover:text-gray-700'}`}>{T.shotMode}</button></div>{mode === 'single' ? (<div className="space-y-2"><div className="flex items-center gap-2 pb-2 border-b border-gray-100">{renderStylePicker('single', { fill: resolveColor(singleDieSettings.colorIdx, singleDieSettings.customColor).fill, borderColor: singleDieSettings.borderColor, borderWidth: singleDieSettings.borderWidth }, handleBorderColorSelect, handleBorderWidthChange)}<span className="text-sm font-bold text-gray-700">Dimensions</span></div><div className="grid grid-cols-2 gap-2"><NumberInput label={labelWithUnit('width')} value={singleParams.width} onChange={v => handleSingleChange('width', v)} /><NumberInput label={labelWithUnit('height')} value={singleParams.height} onChange={v => handleSingleChange('height', v)} /></div><div className="grid grid-cols-2 gap-2"><NumberInput label={labelWithUnit('gridOffsetX')} value={singleParams.offsetX} onChange={v => handleSingleChange('offsetX', v)} /><NumberInput label={labelWithUnit('gridOffsetY')} value={singleParams.offsetY} onChange={v => handleSingleChange('offsetY', v)} /></div><NumberInput label={labelWithUnit('scribe')} value={singleParams.scribe} onChange={v => handleSingleChange('scribe', v)} /><div className="pt-1"><label className="block text-xs font-bold text-gray-400">Alignment</label><AlignmentSelector mode={singleParams.offsetMode} onChange={(m) => handleSingleChange('offsetMode', m)} /></div></div>) : (<div className="space-y-2"><div className="grid grid-cols-2 gap-2"><NumberInput label={labelWithUnit('width')} value={shotParams.width} onChange={v => handleShotChange('width', v)} /><NumberInput label={labelWithUnit('height')} value={shotParams.height} onChange={v => handleShotChange('height', v)} /></div><div className="grid grid-cols-2 gap-2"><NumberInput label={labelWithUnit('shotOffsetX')} value={shotParams.offsetX} onChange={v => handleShotChange('offsetX', v)} /><NumberInput label={labelWithUnit('shotOffsetY')} value={shotParams.offsetY} onChange={v => handleShotChange('offsetY', v)} /></div><div className="grid grid-cols-2 gap-2"><NumberInput label={labelWithUnit('scribeX')} value={shotParams.scribeX} onChange={v => handleShotChange('scribeX', v)} /><NumberInput label={labelWithUnit('scribeY')} value={shotParams.scribeY} onChange={v => handleShotChange('scribeY', v)} /></div><div className="grid grid-cols-2 gap-3 pt-2 border-t border-gray-100 mt-2"><div><label className="block text-xs font-bold text-gray-400">Alignment</label><AlignmentSelector mode={shotParams.offsetMode} onChange={(m) => handleShotChange('offsetMode', m)} /></div><div><div className="flex justify-between items-center mb-0.5"><label className="block text-xs font-bold text-gray-400">Shot Grid</label><input type="checkbox" checked={showShotGrid} onChange={e => setShowShotGrid(e.target.checked)} className="w-3 h-3 text-indigo-600 rounded" title="Toggle Grid Visibility" /></div><div className="flex items-center gap-2 mt-0.5 h-[26px]">{renderStylePicker('shotGrid', { borderColor: shotGridConfig.color, borderWidth: shotGridConfig.width, style: shotGridConfig.style }, handleBorderColorSelect, handleBorderWidthChange, true)}<span className="text-xs text-gray-500">Config</span></div></div></div></div>)}</div></div>
                            {mode === 'shot' && (<div className="space-y-2"><div className="flex justify-between items-center"><h3 className="text-lg font-extrabold text-slate-700 flex items-center gap-2"><Icons.Layers /> {T.mpwSettings}</h3><button onClick={() => setDieDefinitions([...dieDefinitions, { id: Date.now(), label: 'New', width: '5', height: '5', offsetX: '0', offsetY: '0', rows: 1, cols: 1, gapX: 0, gapY: 0, colorIdx: dieDefinitions.length, customColor: null, borderColor: '#000000', borderWidth: 0.5 }])} className="text-xs text-indigo-600 font-bold bg-indigo-50 px-2 py-1 rounded hover:bg-indigo-100 transition flex items-center gap-1 border border-indigo-200"><Icons.Plus /> {T.addDie}</button></div><div className="space-y-2">{dieDefinitions.map((die) => (<div key={die.id} className="bg-white border border-gray-200 rounded-lg p-2.5 relative group hover:border-indigo-300 transition-colors shadow-sm"><button onClick={() => setDieDefinitions(prev => prev.length > 1 ? prev.filter(d => d.id !== die.id) : prev)} className="absolute right-2 top-2 text-gray-300 hover:text-red-500 transition-colors"><Icons.Trash2 /></button><div className="flex items-center gap-2 mb-2 pr-6">{renderStylePicker(die.id, { fill: resolveColor(die.colorIdx, die.customColor).fill, borderColor: die.borderColor, borderWidth: die.borderWidth }, handleBorderColorSelect, handleBorderWidthChange)}<input value={die.label} onChange={(e) => updateDieDef(die.id, 'label', e.target.value)} className="text-base font-bold w-full outline-none border-b border-transparent focus:border-indigo-300 placeholder-gray-300" placeholder="Label" /></div><div className="grid grid-cols-2 gap-2 mb-2"><NumberInput label={labelWithUnit('width')} value={die.width} onChange={val => updateDieDef(die.id, 'width', val)} /><NumberInput label={labelWithUnit('height')} value={die.height} onChange={val => updateDieDef(die.id, 'height', val)} /></div><details className="text-xs group/details"><summary className="cursor-pointer text-gray-400 hover:text-indigo-600 font-medium list-none flex items-center gap-1 mt-1"><span>Array & Position</span><svg className="w-3 h-3 transition-transform group-open/details:rotate-90" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7" /></svg></summary><div className="pt-2 space-y-2"><div className="grid grid-cols-2 gap-2"><NumberInput label="Rows" value={die.rows} onChange={val => updateDieDef(die.id, 'rows', val)} /><NumberInput label="Cols" value={die.cols} onChange={val => updateDieDef(die.id, 'cols', val)} /></div><div className="grid grid-cols-2 gap-2"><NumberInput label="Off X" value={die.offsetX} onChange={val => updateDieDef(die.id, 'offsetX', val)} /><NumberInput label="Off Y" value={die.offsetY} onChange={val => updateDieDef(die.id, 'offsetY', val)} /></div><div className="grid grid-cols-2 gap-2"><NumberInput label="Gap X" value={die.gapX} onChange={val => updateDieDef(die.id, 'gapX', val)} /><NumberInput label="Gap Y" value={die.gapY} onChange={val => updateDieDef(die.id, 'gapY', val)} /></div></div></details></div>))}</div></div>)}
                            <div className="bg-white p-2.5 rounded-lg border border-gray-200 shadow-sm"><NumberInput label={T.defectDensity} value={defectDensity} onChange={v => setDefectDensity(Math.max(0, parseFloat(v)))} step="0.0001" suffix="/mm²"><button onClick={() => setDefectSeed(Date.now())} className="p-1.5 text-gray-400 hover:text-indigo-600 hover:bg-gray-100 rounded transition-colors" title="Randomize Defects (Shuffle)"><Icons.Shuffle /></button></NumberInput></div>
                        </div>
                        <div className="p-3 bg-slate-900 text-white border-t border-slate-800 shadow-[0_-5px_15px_rgba(0,0,0,0.1)]"><h3 className="text-base font-extrabold text-slate-400 mb-2 flex items-center gap-1"><Icons.AlertCircle /> {T.resultStats}</h3><div className="grid grid-cols-2 gap-4 mb-2"><div><div className="text-4xl font-bold text-emerald-400 leading-none">{stats.totalValid}</div><div className="text-xs text-slate-400 mt-0.5 uppercase tracking-wide">Total Good Die</div></div><div><div className="text-4xl font-bold text-orange-400 leading-none">{stats.totalEdge}</div><div className="text-xs text-slate-400 mt-0.5 uppercase tracking-wide">Edge/Partial Die</div></div></div><div className="w-full bg-slate-800 h-1.5 rounded-full overflow-hidden mb-1"><div className="bg-indigo-500 h-full transition-all duration-500" style={{width: `${Math.min(stats.utilization, 100)}%`}}></div></div><div className="flex justify-between text-xs text-slate-500"><span>Area Utilization</span><span>{stats.utilization.toFixed(2)}%</span></div></div>
                    </div>

                    <div className="flex-1 relative overflow-hidden flex flex-col transition-colors duration-300" style={{ backgroundColor: mapBgColor }}>
                        <div className="absolute top-4 right-4 z-10 flex gap-2 items-start"><button onClick={handleExportExcel} className="bg-emerald-600 hover:bg-emerald-500 text-white border border-emerald-700/50 px-4 py-2 rounded-lg shadow-lg transition-all font-medium text-sm flex items-center gap-2 group whitespace-nowrap"><Icons.Sheet /> <span className="hidden sm:inline">{T.exportExcel}</span></button><div className="flex flex-col gap-2 min-w-[120px]"><button onClick={handleExportGDS} className="w-full bg-slate-700 hover:bg-slate-600 text-white border border-slate-600 px-4 py-2 rounded-lg shadow-lg transition-all font-medium text-sm flex items-center justify-center gap-2 group whitespace-nowrap"><Icons.Download /> <span className="hidden sm:inline">{T.exportGDS}</span></button><div onClick={() => setShowLayerModal(true)} className="bg-slate-900 border border-slate-700 rounded-lg p-3 cursor-pointer hover:bg-slate-800 transition-colors shadow-lg w-full"><div className="text-xs text-slate-400 font-bold flex items-center justify-between mb-2">GDS Layers <Icons.Settings /></div><div className="space-y-1 text-xs text-slate-300 font-mono"><div className="flex justify-between gap-2"><span>Wafer</span> <span>L{gdsLayers.wafer}</span></div><div className="flex justify-between gap-2"><span>Good</span> <span>L{gdsLayers.good}</span></div><div className="flex justify-between gap-2"><span>Edge</span> <span>L{gdsLayers.edge}</span></div><div className="flex justify-between gap-2"><span>Defect</span> <span>L{gdsLayers.defect}</span></div>{mode === 'shot' && <div className="flex justify-between gap-2"><span>Shot</span> <span>L{gdsLayers.shot}</span></div>}<div className="flex justify-between gap-2"><span>Center</span> <span>L{gdsLayers.center}</span></div></div></div></div></div>
                        <div className="absolute top-4 left-4 z-10 pointer-events-none"><div className="bg-slate-900 border border-slate-700 rounded-lg p-3 shadow-lg"><div className="text-sm text-slate-400 font-bold mb-2">Yield Map</div>{stats.summary.slice(0, 5).map((item, idx) => (<div key={idx} className="flex items-center gap-2 text-sm text-slate-200 mb-1"><span className="w-2 h-2 rounded-full" style={{ backgroundColor: item.color.fill }}></span><span className="opacity-80">{item.label}:</span><span className="font-bold">{item.valid}</span>{(defectDensity > 0 && item.defect > 0) && <span className="text-slate-500 ml-1">({item.defect} X)</span>}</div>))}{(defectDensity > 0 && stats.totalDefect > 0) && (<div className="flex items-center gap-2 text-sm text-slate-200 mb-1 border-t border-slate-700 pt-1"><span className="w-2 h-2 rounded-full" style={{ backgroundColor: DEFECT_COLOR.fill }}></span><span className="opacity-80">Total Defects:</span><span className="font-bold">{stats.totalDefect}</span></div>)}</div></div>
                        {selectedDie && (<div className="absolute z-30 bg-white/95 backdrop-blur rounded-lg shadow-2xl border border-indigo-100 p-3 popup-window w-48" style={{ left: popupPosition.left + 15, top: popupPosition.top + 15, }}><div className="flex items-center gap-2 mb-2 pb-1 border-b border-gray-100"><div className="w-3 h-3 rounded-full" style={{ background: selectedDie.status==='defect' ? DEFECT_COLOR.fill : resolveColor(selectedDie.colorIdx, selectedDie.customColor).fill }}></div><button onClick={() => setShowDieListModalLabel(selectedDie.label || 'Single')} className="text-xs font-bold text-indigo-700 hover:underline cursor-pointer" title="View list of all dies">{selectedDie.label || 'Die'}</button><div className="ml-auto flex items-center gap-1"><button onClick={() => setSelectedDie(null)} className="text-gray-400 hover:text-red-500"><Icons.X /></button></div></div><div className="space-y-1 text-[10px] text-gray-500"><div className="flex justify-between"><span>Type:</span> <span className="font-mono text-gray-700 capitalize">{selectedDie.status}</span></div><div className="flex justify-between"><span>Shot:</span> <span className="font-mono text-gray-700">({selectedDie.shotC}, {selectedDie.shotR})</span></div><div className="flex justify-between"><span>Size:</span> <span className="font-mono text-gray-700">{(selectedDie.w * (unit==='um'?1000:1)).toFixed(2)} x {(selectedDie.h * (unit==='um'?1000:1)).toFixed(2)} {unit}</span></div><div className="flex justify-between"><span>Center X:</span> <span className="font-mono text-gray-700">{(selectedDie.x * (unit==='um'?1000:1)).toFixed(3)}</span></div><div className="flex justify-between"><span>Center Y:</span> <span className="font-mono text-gray-700">{(selectedDie.y * (unit==='um'?1000:1)).toFixed(3)}</span></div></div></div>)}
                        {showDieListModalLabel && (<DieListModal label={showDieListModalLabel} dies={getDiesForModal(showDieListModalLabel)} unit={unit} onClose={() => setShowDieListModalLabel(null)} />)}
                        {showLayerModal && (<GDSLayerModal layers={gdsLayers} onUpdate={setGdsLayers} onClose={() => setShowLayerModal(false)} />)}
                        {showSaveModal && (<SaveModal onSave={handleSaveProject} onClose={() => setShowSaveModal(false)} />)}
                        {showManager && (<ProjectManager onClose={() => setShowManager(false)} onLoad={handleLoadProject} />)}

                        <div ref={containerRef} className="w-full h-full cursor-grab active:cursor-grabbing relative" onWheel={handleWheel} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}>
                            {stats.isHighDensity && !stats.isTooHeavy && (<div className="absolute inset-0 flex flex-col items-center justify-center pointer-events-none z-20"><div className="bg-slate-900 p-6 rounded-xl border border-orange-500/30 text-center shadow-2xl"><div className="text-orange-500 mb-2 flex justify-center"><Icons.AlertCircle /></div><h3 className="text-white font-bold mb-1">{T.highDensityMsg}</h3><p className="text-xs text-slate-300">{T.highDensityDesc}</p></div></div>)}
                            {stats.isTooHeavy && (<div className="absolute inset-0 flex flex-col items-center justify-center pointer-events-none z-20"><div className="bg-slate-900 p-6 rounded-xl border border-red-500/30 text-center shadow-2xl"><div className="text-red-500 mb-2 flex justify-center"><Icons.AlertCircle /></div><h3 className="text-white font-bold mb-1">{T.tooHeavyMsg}</h3><p className="text-xs text-slate-300">{T.tooHeavyDesc}</p></div></div>)}
                            <canvas ref={canvasRef} className="block w-full h-full" />
                        </div>

                        <div className="absolute bottom-6 right-6 z-10 flex flex-col items-end gap-2 pointer-events-none">
                            <div className="flex flex-col gap-2 bg-black/40 backdrop-blur-md p-1.5 rounded-lg border border-white/10 shadow-xl pointer-events-auto">
                                <button onClick={() => setViewTransform(p => ({...p, k: Math.min(p.k * 1.2, 50)}))} className="p-2 hover:bg-white/10 rounded text-slate-200 transition-colors" title="Zoom In"><Icons.ZoomIn /></button>
                                <button onClick={() => setViewTransform(p => ({...p, k: Math.max(p.k / 1.2, 0.1)}))} className="p-2 hover:bg-white/10 rounded text-slate-200 transition-colors" title="Zoom Out"><Icons.ZoomOut /></button>
                                <div className="w-full h-px bg-white/10 my-0.5"></div>
                                <button onClick={resetView} className="p-2 hover:bg-white/10 rounded text-slate-200 transition-colors" title={T.resetView}><Icons.RefreshCw /></button>
                            </div>
                            <div className="text-[12px] text-slate-500 italic pr-1 select-none">Design by <span className="font-bold">Peng Liu</span></div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<WaferCalculator />);
    </script>
</body>
</html>